#!/usr/bin/python3

"""Quaint markup

Usage:
  quaint (tok|ast|eval|html) [FILE | -s STR]

Arguments:
  FILE          Source file.

Options:
  -h --help     Show this screen.
  -s STR        Use the provided string instead of a file.
"""

from docopt import docopt
from timeit import timeit

from descr import boxy_terminus, HTMLRuleBuilder as RB, descr
from descr.util import Table, Group

from quaint import engine
from quaint.operparse import SyntaxError, Source
from quaint.parser import tokenize, parse
from quaint.engine import evaluate
from quaint.builders import default_engine, html_documents

from ug.format import errors
from quaint.displayrules import ugdescr, rules


class prerror:
    def __enter__(self):
        pass
    def __exit__(self, type, value, traceback):
        if type is None:
            return True
        elif False:# True: # issubclass(type, SyntaxError):
            rules = RB().pclasses(".{@ErrorPrinter} .location", "C=3")
            rules.rearrange(".hl1, .hl2, .hl3, .hlE",
                            lambda classes, children: ["_"]*len(children[0]) if not children[0].strip() else children)

            e = errors.process_error(value)
            pr = boxy_terminus(rules = rules)
            if e is None:
                pr(value)
                return True
            else:
                value.__traceback__ = None
                pr(e)
                return True

def get_source(args):
    if args["FILE"]:
        try:
            s = open(args["FILE"]).read()
            path = args["FILE"]
        except IOError as e:
            exit(e)
    else:
        s = args["-s"]
        path = None
    return s, path

def needs_source(f):
    def newf(args):
        s, path = get_source(args)
        return f(s, path)
    return newf

@needs_source
def x_tok(s, path):
    # print(timeit(lambda: tokenize(Source(s, url = path)), number = 100))
    results = tokenize(Source(s, url = path))
    rules = RB()
    rules.hide(".source_header")
    rules.mclasses(".table > * > .{@str}", {"scalar", "@str"})
    pr = boxy_terminus(rules = rules)
    things = []
    for entry in results:
        # things.append([str(getattr(entry, 'text', '???')), Group([entry.location])])
        things.append([str(entry), Group([entry.location])])
    pr(Table(things))

@needs_source
def x_ast(s, path):
    # print(timeit(lambda: parse(Source(s, url = path)), number = 100))
    result = parse(Source(s, url = path))
    pr = boxy_terminus()
    pr((result), rules = rules, descr = ugdescr)

@needs_source
def x_eval(s, path):
    ast = parse(Source(s, url = path))
    documents = html_documents()
    evaluate(ast, default_engine(), documents)
    print("\x1B[?0;7y:h <div>" + documents['main'].data + "</div>\a")

@needs_source
def x_html(s, path):
    # print("ast", timeit(lambda: parse(Source(s, url = path)), number = 1) * 1000)
    ast = parse(Source(s, url = path))
    # print("eval", timeit(lambda: evaluate(ast), number = 1) * 1000)

    # main = HTMLDocument()
    # documents = {'main': main,
    #              'sections': SectionsDocument()}

    documents = html_documents()
    documents['xlinks'].add('stylesheet', 'style/main.css')
    documents['xlinks'].add('stylesheet', 'style/pygments.css')
    evaluate(ast, default_engine(), documents)

    html = engine.generate_html_file(documents)
    print(html)

    # print("\x1B[?0;7y:h <div>" + documents['main'].data + "</div>\a")


if __name__ == '__main__':
    args = docopt(__doc__)

    with prerror() as p:
        for possibility in "tok ast eval html".split():
            if args[possibility]:
                globals()["x_"+possibility](args)
                break


